<?xml version="1.0"?><st-source><!-- Name: MessagePack-RuntimeNotice: Copyright (C) 2011- Masashi UmezawaBundleName: MessagePack-RuntimeBundleStructure: a Store.BundleForParcelComment: ** MessagePack for VisualWorks **MessagePack is a compact binary serialization format (http://msgpack.org/)."Extremely efficient object serialization library for cross-language communication. It's like JSON, but very fast and small."This bundle includes minimal set for using MessagePack.(MessagePack-RPC is out of scope, currently).Copyright (C) 2011- Masashi UmezawaPackageName: MessagePack-RuntimeParcel: nilParcelName: MessagePack-RuntimePrerequisiteParcels: #(#('System-Name Spaces' ''))Version: 1.13Date: 9:27:48 AM May 11, 2012 --><time-stamp>From VisualWorks®, 7.8 of 2011年3月30日 on 2012年5月11日 at 09:27:48</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MpTypeMapper</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actionMap </inst-vars><class-inst-vars>actionMap </class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpDecodeTypeMapper</name><environment>Smalltalk</environment><super>MpTypeMapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decoder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpPortableUtil</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpConstants</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpEncoder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>writeStream typeMapper settings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpSettings</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>settingsDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpEncodeTypeMapper</name><environment>Smalltalk</environment><super>MpTypeMapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpMessagePack</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpError</name><environment>Smalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpMemoryWriteStream</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>chunks currentChunk chunkPosition chunkSize lastSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpDecoder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readStream typeMapper settings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpVwEncodeTypeMapper</name><environment>Smalltalk</environment><super>MpEncodeTypeMapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Squeak-Core</category><attributes><package>MessagePack-VW</package></attributes></class><class><name>MpVwPortableUtil</name><environment>Smalltalk</environment><super>MpPortableUtil</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Squeak-Core</category><attributes><package>MessagePack-VW</package></attributes></class><shared-variable><name>Default</name><environment>MpMessagePack</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>MessagePack-Core</package></attributes></shared-variable><shared-variable><name>DialectSpecificClass</name><environment>MpMessagePack</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>MessagePack-Core</package></attributes></shared-variable><shared-variable><name>Default</name><environment>MpPortableUtil</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>MessagePack-Core</package></attributes></shared-variable><shared-variable><name>DialectSpecificClass</name><environment>MpPortableUtil</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>MessagePack-Core</package></attributes></shared-variable><methods><class-id>MpTypeMapper</class-id> <category>initialization</category><body package="MessagePack-Core" selector="initActionMaps">initActionMaps	"override for custom mapping"	actionMap := nil</body></methods><methods><class-id>MpTypeMapper</class-id> <category>accessing</category><body package="MessagePack-Core" selector="actionMap">actionMap	^ actionMap ifNil: [actionMap := IdentityDictionary new]</body><body package="MessagePack-Core" selector="defaultActionMap">defaultActionMap	^ self class actionMap</body></methods><methods><class-id>MpTypeMapper class</class-id> <category>actions for compounds</category><body package="MessagePack-Core" selector="defineCompoundsActionsTo:">defineCompoundsActionsTo: map	"override"</body></methods><methods><class-id>MpTypeMapper class</class-id> <category>factory</category><body package="MessagePack-Core" selector="createActionMap">createActionMap	| map |	map := IdentityDictionary new.	self definePrimitivesActionsTo: map.	self defineCompoundsActionsTo: map.	^map</body></methods><methods><class-id>MpTypeMapper class</class-id> <category>class initialization</category><body package="MessagePack-Core" selector="initialize">initialize	"self initialize"	actionMap  := nil.	self actionMap</body><body package="MessagePack-Core" selector="initializeAll">initializeAll	"self initializeAll"	self allSubclasses do: [:each | each initialize]</body></methods><methods><class-id>MpTypeMapper class</class-id> <category>actions for primitives</category><body package="MessagePack-Core" selector="definePrimitivesActionsTo:">definePrimitivesActionsTo: map	"override"</body></methods><methods><class-id>MpTypeMapper class</class-id> <category>accessing</category><body package="MessagePack-Core" selector="actionMap">actionMap	^ actionMap ifNil: [actionMap := self createActionMap]</body></methods><methods><class-id>MpDecodeTypeMapper</class-id> <category>accessing</category><body package="MessagePack-Core" selector="decoder">decoder	"Answer the value of decoder"	^ decoder</body><body package="MessagePack-Core" selector="decoder:">decoder: anObject	"Set the value of decoder"	decoder := anObject</body></methods><methods><class-id>MpDecodeTypeMapper</class-id> <category>actions</category><body package="MessagePack-Core" selector="readObjectOf:ifNotApplied:">readObjectOf: typeCode ifNotApplied: aBlock 	| actionSelector |		actionMap		ifNotNil: [actionSelector := self actionMap at: typeCode ifAbsent: [].			actionSelector ifNotNil: [^ self decoder perform: actionSelector]].		actionSelector := self defaultActionMap				at: typeCode				ifAbsent: [^ aBlock value].	^ self decoder perform: actionSelector</body></methods><methods><class-id>MpDecodeTypeMapper class</class-id> <category>actions for primitives</category><body package="MessagePack-Core" selector="defineDoubleActionTo:">defineDoubleActionTo: map	map at: MpConstants double put: #readDouble</body><body package="MessagePack-Core" selector="defineFalseActionTo:">defineFalseActionTo: map	map at: MpConstants false put: #readFalse</body><body package="MessagePack-Core" selector="defineFloatActionTo:">defineFloatActionTo: map	map at: MpConstants float put: #readFloat</body><body package="MessagePack-Core" selector="defineIntegerActionTo:">defineIntegerActionTo: map	map at: MpConstants int8 put: #readInt8.	map at: MpConstants int16 put: #readInt16.	map at: MpConstants int32 put: #readInt32.	map at: MpConstants int64 put: #readInt64.</body><body package="MessagePack-Core" selector="defineNilActionTo:">defineNilActionTo: map	map at: MpConstants nil put: #readNil</body><body package="MessagePack-Core" selector="definePrimitivesActionsTo:">definePrimitivesActionsTo: map	self defineNilActionTo: map.	self defineFalseActionTo: map.	self defineTrueActionTo: map.	self defineFloatActionTo: map.	self defineDoubleActionTo: map.	self defineUnsignedIntegerActionTo: map.	self defineIntegerActionTo: map.	self defineRawBytesActionTo: map.</body><body package="MessagePack-Core" selector="defineRawBytesActionTo:">defineRawBytesActionTo: map	map at: MpConstants raw16 put: #readRaw16.	map at: MpConstants raw32 put: #readRaw32.</body><body package="MessagePack-Core" selector="defineTrueActionTo:">defineTrueActionTo: map	map at: MpConstants true put: #readTrue</body><body package="MessagePack-Core" selector="defineUnsignedIntegerActionTo:">defineUnsignedIntegerActionTo: map	map at: MpConstants uint8 put: #readUint8.	map at: MpConstants uint16 put: #readUint16.	map at: MpConstants uint32 put: #readUint32.	map at: MpConstants uint64 put: #readUint64.</body></methods><methods><class-id>MpDecodeTypeMapper class</class-id> <category>actions for compounds</category><body package="MessagePack-Core" selector="defineArrayActionTo:">defineArrayActionTo: map	map at: MpConstants array16 put: #readArray16.	map at: MpConstants array32 put: #readArray32.</body><body package="MessagePack-Core" selector="defineCompoundsActionsTo:">defineCompoundsActionsTo: map	self defineArrayActionTo: map.	self defineMapActionTo: map.</body><body package="MessagePack-Core" selector="defineMapActionTo:">defineMapActionTo: map		map at: MpConstants map16 put: #readMap16.	map at: MpConstants map32 put: #readMap32.</body></methods><methods><class-id>MpDecodeTypeMapper class</class-id> <category>instance creation</category><body package="MessagePack-Core" selector="on:">on: mpDecoder 	^ self new decoder: mpDecoder;		 initActionMaps;		 yourself</body></methods><methods><class-id>MpPortableUtil</class-id> <category>actions-stream</category><body package="MessagePack-Core" selector="readDoubleFrom:">readDoubleFrom: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="readFloatFrom:">readFloatFrom: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="readInt16From:">readInt16From: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="readInt32From:">readInt32From: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="readInt64From:">readInt64From: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="readUint16From:">readUint16From: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="readUint32From:">readUint32From: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="readUint64From:">readUint64From: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="writeDouble:to:">writeDouble: value to: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="writeFloat:to:">writeFloat: value to: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="writeInt16:to:">writeInt16: value to: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="writeInt32:to:">writeInt32: value to: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="writeInt64:to:">writeInt64: value to: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="writeUint16:to:">writeUint16: value to: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="writeUint32:to:">writeUint32: value to: stream	self subclassResponsibility</body><body package="MessagePack-Core" selector="writeUint64:to:">writeUint64: value to: stream	self subclassResponsibility</body></methods><methods><class-id>MpPortableUtil</class-id> <category>factory</category><body package="MessagePack-Core" selector="encodeTypeMapperClass">encodeTypeMapperClass	^MpEncodeTypeMapper</body><body package="MessagePack-Core" selector="newCollection:sized:withAll:">newCollection: aCollectionClass sized: size withAll: elem	^ aCollectionClass new: size withAll: elem</body><body package="MessagePack-Core" selector="randomClass">randomClass	"For testing"	^Smalltalk at: #Random</body></methods><methods><class-id>MpPortableUtil</class-id> <category>actions</category><body package="MessagePack-Core" selector="bytesFromString:">bytesFromString: aString	^aString asByteArray</body><body package="MessagePack-Core" selector="signalException:">signalException: anException	"Ansi"	^anException signal</body></methods><methods><class-id>MpPortableUtil</class-id> <category>testing</category><body package="MessagePack-Core" selector="collectionEquals:with:">collectionEquals: aCollection with: otherCollection	"For testing"	^ aCollection = otherCollection</body></methods><methods><class-id>MpPortableUtil</class-id> <category>defaults</category><body package="MessagePack-Core" selector="useFastBulkWrite">useFastBulkWrite	^ false</body></methods><methods><class-id>MpPortableUtil class</class-id> <category>class initialization</category><body package="MessagePack-Core" selector="initialize">initialize	Default := nil.	DialectSpecificClass := nil</body></methods><methods><class-id>MpPortableUtil class</class-id> <category>instance creation</category><body package="MessagePack-Core" selector="default">default	^Default ifNil: [Default := self dialectSpecificClass new]</body></methods><methods><class-id>MpPortableUtil class</class-id> <category>factory</category><body package="MessagePack-Core" selector="dialectSpecificClass">dialectSpecificClass	^DialectSpecificClass ifNil: [DialectSpecificClass := self subclasses at: 1]</body><body package="MessagePack-Core" selector="dialectSpecificClass:">dialectSpecificClass: aClass	DialectSpecificClass := aClass</body></methods><methods><class-id>MpConstants class</class-id> <category>typecodes</category><body package="MessagePack-Core" selector="array16">array16	^16rDC</body><body package="MessagePack-Core" selector="array32">array32	^16rDD</body><body package="MessagePack-Core" selector="double">double	^16rCB</body><body package="MessagePack-Core" selector="false">false	^16rC2</body><body package="MessagePack-Core" selector="float">float	^16rCA</body><body package="MessagePack-Core" selector="int16">int16	^16rD1</body><body package="MessagePack-Core" selector="int32">int32	^16rD2</body><body package="MessagePack-Core" selector="int64">int64	^16rD3</body><body package="MessagePack-Core" selector="int8">int8	^16rD0</body><body package="MessagePack-Core" selector="map16">map16	^16rDE</body><body package="MessagePack-Core" selector="map32">map32	^16rDF</body><body package="MessagePack-Core" selector="nil">nil	^16rC0</body><body package="MessagePack-Core" selector="raw16">raw16	^16rDA</body><body package="MessagePack-Core" selector="raw32">raw32	^16rDB</body><body package="MessagePack-Core" selector="true">true	^16rC3</body><body package="MessagePack-Core" selector="uint16">uint16	^16rCD</body><body package="MessagePack-Core" selector="uint32">uint32	^16rCE</body><body package="MessagePack-Core" selector="uint64">uint64	^16rCF</body><body package="MessagePack-Core" selector="uint8">uint8	^16rCC</body></methods><methods><class-id>MpEncoder</class-id> <category>dispatching</category><body package="MessagePack-Core" selector="writeObject:">writeObject: anObject 	^self		writeObject: anObject		ifNotApplied: [self signalError]</body><body package="MessagePack-Core" selector="writeObject:ifNotApplied:">writeObject: anObject ifNotApplied: aBlock 	^self typeMapper writeObject: anObject ifNotApplied: aBlock</body></methods><methods><class-id>MpEncoder</class-id> <category>accessing</category><body package="MessagePack-Core" selector="contents">contents	^self writeStream contents</body><body package="MessagePack-Core" selector="settings">settings	^settings ifNil: [settings := self settingsClass new]</body><body package="MessagePack-Core" selector="typeMapper">typeMapper	^ typeMapper		ifNil: [typeMapper := self typeMapperClass on: self.			self settings stringAsBytes ifTrue: [typeMapper stringAsBytes].			typeMapper]</body><body package="MessagePack-Core" selector="typeMapperClass">typeMapperClass	^MpPortableUtil default encodeTypeMapperClass</body><body package="MessagePack-Core" selector="writeStream">writeStream	writeStream isNil		ifTrue: [writeStream := self createWriteStream].	^ writeStream</body><body package="MessagePack-Core" selector="writeStream:">writeStream: anObject	"Set the value of writeStream"	writeStream := anObject</body></methods><methods><class-id>MpEncoder</class-id> <category>writing</category><body package="MessagePack-Core" selector="writeArray:">writeArray: array	| size |	size := array size.	self writeArraySize: size.	array do: [:each | self writeObject: each].</body><body package="MessagePack-Core" selector="writeDouble:">writeDouble: aFloat	self writeStream nextPut: MpConstants double.	MpPortableUtil default writeDouble: aFloat to: self writeStream</body><body package="MessagePack-Core" selector="writeFalse:">writeFalse: ignore	self writeStream nextPut: MpConstants false</body><body package="MessagePack-Core" selector="writeFloat:">writeFloat: aFloat	self writeStream nextPut: MpConstants float.	MpPortableUtil default writeFloat: aFloat to: self writeStream</body><body package="MessagePack-Core" selector="writeInteger:">writeInteger: anInteger 	(anInteger between: 0 and: 127)		ifTrue: [^self writePositiveFixNum: anInteger].			(anInteger between: -32 and: -1)		ifTrue: [^self writeNegativeFixNum: anInteger].		anInteger &gt;= 128 ifTrue: [		anInteger &lt;= 255 ifTrue: [^self writeUint8: anInteger].		anInteger &lt;= 65535 ifTrue: [^self writeUint16: anInteger].		anInteger &lt;= 4294967295 ifTrue: [^self writeUint32: anInteger].		anInteger &lt;= 18446744073709551615 ifTrue: [^self writeUint64: anInteger].	].		anInteger &gt;= -128 ifTrue: [^self writeInt8: anInteger].	anInteger &gt;= -32768 ifTrue: [^self writeInt16: anInteger].	anInteger &gt;= -2147483648 ifTrue: [^self writeInt32: anInteger].	anInteger &gt;= -9223372036854775808 ifTrue: [^self writeInt64: anInteger].		self signalError</body><body package="MessagePack-Core" selector="writeMap:">writeMap: aDictionary	| size |	size := aDictionary size.	self writeMapSize: size.	aDictionary keysAndValuesDo: [:key :value | self writeObject: key; writeObject: value].</body><body package="MessagePack-Core" selector="writeNil:">writeNil: ignore	self writeStream nextPut: MpConstants nil</body><body package="MessagePack-Core" selector="writeRawBytes:">writeRawBytes: bytes	| size |	size := bytes size.	self writeRawBytesSize: size.	self writeStream nextPutAll: bytes</body><body package="MessagePack-Core" selector="writeTrue:">writeTrue: ignore	self writeStream nextPut: MpConstants true</body></methods><methods><class-id>MpEncoder</class-id> <category>writing-helper</category><body package="MessagePack-Core" selector="writeArraySize:">writeArraySize: size	size &lt; 16r10 ifTrue: [^ self writeStream nextPut: (2r10010000 bitOr: size)].	size &lt; 16r10000  ifTrue: [		self writeStream nextPut: MpConstants array16.		^MpPortableUtil default writeUint16: size to: self writeStream	].	size &lt; 16r100000000  ifTrue: [		self writeStream nextPut: MpConstants array32.		^MpPortableUtil default writeUint32: size to: self writeStream	].		self signalError</body><body package="MessagePack-Core" selector="writeInt16:">writeInt16: value	self writeStream nextPut: MpConstants int16.	MpPortableUtil default writeInt16: value to: self writeStream</body><body package="MessagePack-Core" selector="writeInt32:">writeInt32: value	self writeStream nextPut: MpConstants int32.	MpPortableUtil default writeInt32: value to: self writeStream</body><body package="MessagePack-Core" selector="writeInt64:">writeInt64: value	self writeStream nextPut: MpConstants int64.	MpPortableUtil default writeInt64: value to: self writeStream</body><body package="MessagePack-Core" selector="writeInt8:">writeInt8: value	| val |	self writeStream nextPut: MpConstants int8.	val := value &lt; 0 ifTrue: [256 + value] ifFalse: [value].	self writeStream nextPut: val</body><body package="MessagePack-Core" selector="writeMapSize:">writeMapSize: size	size &lt; 16r10 ifTrue: [^ self writeStream nextPut: (2r10000000 bitOr: size)].	size &lt; 16r10000  ifTrue: [		self writeStream nextPut: MpConstants map16.		^MpPortableUtil default writeUint16: size to: self writeStream	].	size &lt; 16r100000000  ifTrue: [		self writeStream nextPut: MpConstants map32.		^MpPortableUtil default writeUint32: size to: self writeStream	].		self signalError</body><body package="MessagePack-Core" selector="writeNegativeFixNum:">writeNegativeFixNum: number	"-32 to -1"	| val |	val :=  256 + number.	self writeStream nextPut: val</body><body package="MessagePack-Core" selector="writePositiveFixNum:">writePositiveFixNum: number	self writeStream nextPut: number</body><body package="MessagePack-Core" selector="writeRawBytesSize:">writeRawBytesSize: size	size &lt; 16r10 ifTrue: [^ self writeStream nextPut: (2r10100000 bitOr: size)].	size &lt; 16r10000  ifTrue: [		self writeStream nextPut: MpConstants raw16.		^MpPortableUtil default writeUint16: size to: self writeStream	].	size &lt; 16r100000000  ifTrue: [		self writeStream nextPut: MpConstants raw32.		^MpPortableUtil default writeUint32: size to: self writeStream	].		self signalError</body><body package="MessagePack-Core" selector="writeUint16:">writeUint16: value	self writeStream nextPut: MpConstants uint16.	MpPortableUtil default writeUint16: value to: self writeStream</body><body package="MessagePack-Core" selector="writeUint32:">writeUint32: value	self writeStream nextPut: MpConstants uint32.	MpPortableUtil default writeUint32: value to: self writeStream</body><body package="MessagePack-Core" selector="writeUint64:">writeUint64: value	self writeStream nextPut: MpConstants uint64.	MpPortableUtil default writeUint64: value to: self writeStream</body><body package="MessagePack-Core" selector="writeUint8:">writeUint8: value	self writeStream nextPut: MpConstants uint8.	self writeStream nextPut: value</body></methods><methods><class-id>MpEncoder</class-id> <category>factory</category><body package="MessagePack-Core" selector="createWriteStream">createWriteStream	self settings fastBulkWrite ifTrue: [		^ MpMemoryWriteStream chunkSized: self settings defaultStreamSize.		].	^WriteStream on: (ByteArray new: self settings defaultStreamSize).</body><body package="MessagePack-Core" selector="settingsClass">settingsClass	^MpSettings</body></methods><methods><class-id>MpEncoder</class-id> <category>encoding</category><body package="MessagePack-Core" selector="encode:">encode: anObject	^self encode: anObject on: self writeStream</body><body package="MessagePack-Core" selector="encode:on:">encode: anObject on: aStream	self write: anObject on: aStream.	^self contents.</body><body package="MessagePack-Core" selector="write:on:">write: anObject on: aStream	self writeStream: aStream "binary".	self writeObject: anObject</body></methods><methods><class-id>MpEncoder</class-id> <category>signaling error</category><body package="MessagePack-Core" selector="signalError">signalError	self signalError: 'Cannot encode'</body><body package="MessagePack-Core" selector="signalError:">signalError: message	^MpPortableUtil default signalException: (MpError encode messageText: message)</body></methods><methods><class-id>MpEncoder</class-id> <category>stream-like</category><body package="MessagePack-Core" selector="nextPut:">nextPut: anObject	self writeObject: anObject</body><body package="MessagePack-Core" selector="nextPutAll:">nextPutAll: aCollection	aCollection do: [:each | self nextPut: each]</body></methods><methods><class-id>MpEncoder</class-id> <category>writing-string</category><body package="MessagePack-Core" selector="writeString:">writeString: aString	self writeRawBytes: aString asByteArray</body><body package="MessagePack-Core" selector="writeWideString:">writeWideString: aString	self writeRawBytes: (MpPortableUtil default bytesFromString: aString)</body></methods><methods><class-id>MpEncoder class</class-id> <category>actions</category><body package="MessagePack-Core" selector="encode:">encode: anObject 	^self new encode: anObject</body><body package="MessagePack-Core" selector="encode:on:">encode: anObject on: aStream	^self new encode: anObject on: aStream</body><body package="MessagePack-Core" selector="on:">on: aStream	^self new writeStream: aStream; yourself</body><body package="MessagePack-Core" selector="onBytes:">onBytes: byteArray	^self on: (WriteStream on: byteArray).</body></methods><methods><class-id>MpSettings</class-id> <category>actions-dictionary</category><body package="MessagePack-Core" selector="at:">at: key	^self settingsDict at: key</body><body package="MessagePack-Core" selector="at:ifAbsent:">at: key ifAbsent: aBlock	^self settingsDict at: key ifAbsent: aBlock</body><body package="MessagePack-Core" selector="at:ifAbsentPut:">at: key ifAbsentPut: aBlock	^self settingsDict at: key ifAbsentPut: aBlock</body><body package="MessagePack-Core" selector="at:put:">at: key put: value	^self settingsDict at: key put: value</body><body package="MessagePack-Core" selector="includesKey:">includesKey: key	^self settingsDict includesKey: key</body><body package="MessagePack-Core" selector="keys">keys	^self settingsDict keys</body></methods><methods><class-id>MpSettings</class-id> <category>accessing-private</category><body package="MessagePack-Core" selector="settingsDict">settingsDict	^ settingsDict ifNil: [settingsDict := IdentityDictionary new]</body></methods><methods><class-id>MpSettings</class-id> <category>accessing</category><body package="MessagePack-Core" selector="defaultStreamSize">defaultStreamSize	^self at: #defaultStreamSize ifAbsentPut: [1024]</body><body package="MessagePack-Core" selector="defaultStreamSize:">defaultStreamSize: anInteger	^self at: #defaultStreamSize put: anInteger</body><body package="MessagePack-Core" selector="fastBulkWrite">fastBulkWrite	^self at: #fastBulkWrite ifAbsentPut: [MpPortableUtil default useFastBulkWrite]</body><body package="MessagePack-Core" selector="fastBulkWrite:">fastBulkWrite: aBoolean	^self at: #fastBulkWrite put: aBoolean</body><body package="MessagePack-Core" selector="stringAsBytes">stringAsBytes	^self at: #stringAsBytes ifAbsentPut: [false]</body><body package="MessagePack-Core" selector="stringAsBytes:">stringAsBytes: aBoolean	^self at: #stringAsBytes ifAbsentPut: aBoolean</body></methods><methods><class-id>MpSettings</class-id> <category>class initialization</category><body package="MessagePack-Core" selector="initialize">initialize	settingsDict := nil</body></methods><methods><class-id>MpEncodeTypeMapper</class-id> <category>accessing</category><body package="MessagePack-Core" selector="encoder">encoder	"Answer the value of encoder"	^ encoder</body><body package="MessagePack-Core" selector="encoder:">encoder: anObject	"Set the value of encoder"	encoder := anObject</body></methods><methods><class-id>MpEncodeTypeMapper</class-id> <category>actions</category><body package="MessagePack-Core" selector="writeObject:ifNotApplied:">writeObject: anObject ifNotApplied: aBlock 	| actionSelector |	actionMap		ifNotNil: [actionSelector := self actionMap at: anObject class ifAbsent: [].			actionSelector ifNotNil: [^ self encoder perform: actionSelector with: anObject]].			actionSelector := anObject mpWriteSelector.	actionSelector ifNil: [actionSelector := self defaultActionMap at: anObject class ifAbsent: [^ aBlock value]].	^ self encoder perform: actionSelector with: anObject</body></methods><methods><class-id>MpEncodeTypeMapper</class-id> <category>encode customization</category><body package="MessagePack-Core" selector="stringAsBytes">stringAsBytes	self actionMap at: String put: #writeString:</body></methods><methods><class-id>MpEncodeTypeMapper class</class-id> <category>actions for compounds</category><body package="MessagePack-Core" selector="defineArrayActionTo:">defineArrayActionTo: map	map at: Array put: #writeArray:.</body><body package="MessagePack-Core" selector="defineCompoundsActionsTo:">defineCompoundsActionsTo: map	self defineArrayActionTo: map.	self defineMapActionTo: map.</body><body package="MessagePack-Core" selector="defineMapActionTo:">defineMapActionTo: map		map at: Dictionary put: #writeMap:.	"map at: IdentityDictionary put: #writeDictionary:"</body></methods><methods><class-id>MpEncodeTypeMapper class</class-id> <category>actions for primitives</category><body package="MessagePack-Core" selector="defineDoubleActionTo:">defineDoubleActionTo: map	"Some dialect does not support Double"	"map at: Double put: #writeDouble:"</body><body package="MessagePack-Core" selector="defineFalseActionTo:">defineFalseActionTo: map	map at: False put: #writeFalse:</body><body package="MessagePack-Core" selector="defineFloatActionTo:">defineFloatActionTo: map	"Suppose 32 bit float - Some dialect does not support it"	"map at: Float put: #writeFloat:"</body><body package="MessagePack-Core" selector="defineIntegerActionTo:">defineIntegerActionTo: map	Integer allSubclasses do: [:each |		map at: each put: #writeInteger:	]</body><body package="MessagePack-Core" selector="defineNilActionTo:">defineNilActionTo: map	map at: UndefinedObject put: #writeNil:</body><body package="MessagePack-Core" selector="definePrimitivesActionsTo:">definePrimitivesActionsTo: map	self defineRawBytesActionTo: map.	self defineIntegerActionTo: map.	self defineFloatActionTo: map.	self defineDoubleActionTo: map.	self defineNilActionTo: map.	self defineTrueActionTo: map.	self defineFalseActionTo: map.</body><body package="MessagePack-Core" selector="defineRawBytesActionTo:">defineRawBytesActionTo: map	map at: ByteArray put: #writeRawBytes:</body><body package="MessagePack-Core" selector="defineTrueActionTo:">defineTrueActionTo: map	map at: True put: #writeTrue:</body></methods><methods><class-id>MpEncodeTypeMapper class</class-id> <category>instance creation</category><body package="MessagePack-Core" selector="on:">on: mpEncoder 	^ self new encoder: mpEncoder;		 initActionMaps;		 yourself</body></methods><methods><class-id>MpMessagePack class</class-id> <category>utilities</category><body package="MessagePack-Core" selector="pack:">pack: anObject	^ MpEncoder encode: anObject</body><body package="MessagePack-Core" selector="packUnpack:">packUnpack: anObject	^self unpack: (self pack: anObject)</body><body package="MessagePack-Core" selector="unpack:">unpack: aByteArray	^ MpDecoder decode: aByteArray</body></methods><methods><class-id>MpError</class-id> <category>accessing</category><body package="MessagePack-Core" selector="type">type	"Answer the value of type"	^ type</body><body package="MessagePack-Core" selector="type:">type: anObject	"Set the value of type"	type := anObject</body></methods><methods><class-id>MpError class</class-id> <category>instance creation</category><body package="MessagePack-Core" selector="decode">decode	^self new type: #decode</body><body package="MessagePack-Core" selector="encode">encode	^self new type: #encode</body></methods><methods><class-id>MpMemoryWriteStream</class-id> <category>public</category><body package="MessagePack-Core" selector="asByteArray">asByteArray	"Answer receiver as byte array."	| bytes pos idx len coll bytesSize |	bytes := ByteArray new: (bytesSize := self size).	pos := 0.	idx := 1.		[coll := self chunks at: idx.	len := coll size.	pos + len &lt; bytesSize] whileTrue: 				[bytes					replaceFrom: pos + 1					to: (pos := pos + len)					with: coll					startingAt: 1.				idx := idx + 1].	bytes		replaceFrom: pos + 1		to: bytesSize		with: coll		startingAt: 1.	^bytes</body><body package="MessagePack-Core" selector="contents">contents	^self asByteArray</body><body package="MessagePack-Core" selector="nextPut:">nextPut: integer	self chunkPosition &gt;= self chunkSize ifTrue: [self moveToNext].	self chunkPosition: self chunkPosition + 1.	self currentChunk at: self chunkPosition put: integer</body><body package="MessagePack-Core" selector="nextPutAll:">nextPutAll: bytes	self putBytes: bytes sized: bytes size</body><body package="MessagePack-Core" selector="position">position	| idx size coll |	self currentChunk isNil ifTrue: [^0].	idx := 1.	size := 0.	[(coll := self chunks at: idx) == self currentChunk] whileFalse: 			[idx := idx + 1.			size := size + coll size].	^size + self chunkPosition</body><body package="MessagePack-Core" selector="size">size	| size count |	self currentChunk isNil ifTrue: [^0].	size := 0.	count := self chunks size.	1 to: count - 1 do: [:idx | size := size + (self chunks at: idx) size].	self currentChunk == (self chunks at: count) 		ifTrue: [self lastSize &lt; self chunkPosition ifTrue: [self lastSize: self chunkPosition]].	^size + self lastSize</body></methods><methods><class-id>MpMemoryWriteStream</class-id> <category>accessing</category><body package="MessagePack-Core" selector="chunkPosition">chunkPosition	^chunkPosition</body><body package="MessagePack-Core" selector="chunkPosition:">chunkPosition: anObject	^chunkPosition := anObject</body><body package="MessagePack-Core" selector="chunkSize">chunkSize	^chunkSize ifNil: [chunkSize := 1024]</body><body package="MessagePack-Core" selector="chunkSize:">chunkSize: anObject	chunkSize := anObject</body><body package="MessagePack-Core" selector="chunks">chunks	^chunks</body><body package="MessagePack-Core" selector="chunks:">chunks: anObject	chunks := anObject</body><body package="MessagePack-Core" selector="currentChunk">currentChunk	^currentChunk</body><body package="MessagePack-Core" selector="currentChunk:">currentChunk: anObject	^currentChunk := anObject</body><body package="MessagePack-Core" selector="lastSize">lastSize	^lastSize</body><body package="MessagePack-Core" selector="lastSize:">lastSize: anObject	lastSize := anObject</body></methods><methods><class-id>MpMemoryWriteStream</class-id> <category>private</category><body package="MessagePack-Core" selector="makeSpace">makeSpace	self chunks add: self prepareCurrentChunk.	self chunkPosition: 0.	self lastSize: 0</body><body package="MessagePack-Core" selector="moveToNext">moveToNext	| curChunk |	self chunkPosition: 0.	curChunk := self currentChunk.	(curChunk isNil or: [curChunk == self chunks last])		ifTrue: 			[self makeSpace]		ifFalse: 			[1 to: self chunks size				do: 					[:idx |					(self chunks at: idx) == curChunk						ifTrue: 							[self currentChunk: (self chunks at: idx + 1).							^self]]]</body><body package="MessagePack-Core" selector="prepareCurrentChunk">prepareCurrentChunk	^self currentChunk: (ByteArray new: self chunkSize)</body><body package="MessagePack-Core" selector="putBytes:sized:">putBytes: bytes sized: len 	len &gt; (self chunkSize - self chunkPosition) 		ifTrue: 			[(self currentChunk notNil 				and: [self chunks last == self currentChunk and: [len &gt; 64]]) 					ifTrue: 						[self chunks at: self chunks size put: (self currentChunk copyFrom: 1 to: self chunkPosition).						self chunks add: bytes.						self makeSpace]					ifFalse: [1 to: len do: [:i | self nextPut: (bytes at: i)]]]		ifFalse: 			[self currentChunk 				replaceFrom: self chunkPosition + 1				to: self chunkPosition + len				with: bytes				startingAt: 1.			self chunkPosition: self chunkPosition + len]</body></methods><methods><class-id>MpMemoryWriteStream</class-id> <category>initialize-release</category><body package="MessagePack-Core" selector="initialize">initialize	chunks := OrderedCollection new.	self makeSpace</body></methods><methods><class-id>MpMemoryWriteStream class</class-id> <category>instance creation</category><body package="MessagePack-Core" selector="chunkSized:">chunkSized: chunkSize	^(self basicNew)		chunkSize: chunkSize;		initialize;		yourself</body><body package="MessagePack-Core" selector="new">new    ^super new initialize</body></methods><methods><class-id>MpDecoder</class-id> <category>reading</category><body package="MessagePack-Core" selector="read">read	^self readObject.</body><body package="MessagePack-Core" selector="readArray16">readArray16	| size |	size := MpPortableUtil default readUint16From: self readStream.	^ self readArraySized: size</body><body package="MessagePack-Core" selector="readArray32">readArray32	| size |	size := MpPortableUtil default readUint32From: self readStream.	^ self readArraySized: size</body><body package="MessagePack-Core" selector="readDouble">readDouble	"64 bit"	^MpPortableUtil default readDoubleFrom: self readStream</body><body package="MessagePack-Core" selector="readFalse">readFalse	^false</body><body package="MessagePack-Core" selector="readFixArray:">readFixArray: firstByte	| size |	size := (firstByte bitAnd: 2r1111).	^ self readArraySized: size</body><body package="MessagePack-Core" selector="readFixMap:">readFixMap: firstByte	| size |	size := (firstByte bitAnd: 2r1111).	^self readMapSized: size</body><body package="MessagePack-Core" selector="readFixRaw:">readFixRaw: firstByte	| size |	size := (firstByte bitAnd: 2r11111).	^self readStream next: size</body><body package="MessagePack-Core" selector="readFloat">readFloat	"32 bit"	^MpPortableUtil default readFloatFrom: self readStream</body><body package="MessagePack-Core" selector="readMap16">readMap16	| size |	size := MpPortableUtil default readUint16From: self readStream.	^ self readMapSized: size</body><body package="MessagePack-Core" selector="readMap32">readMap32	| size |	size := MpPortableUtil default readUint32From: self readStream.	^ self readMapSized: size</body><body package="MessagePack-Core" selector="readNegativeFixNum:">readNegativeFixNum: firstByte	| val |	val := (firstByte bitAnd: 2r11111).	^ val - 32</body><body package="MessagePack-Core" selector="readNil">readNil	^nil</body><body package="MessagePack-Core" selector="readPositiveFixNum:">readPositiveFixNum: firstByte	"0 - 127"	^ firstByte</body><body package="MessagePack-Core" selector="readRaw16">readRaw16	| size |	size := MpPortableUtil default readUint16From: self readStream.	^self readStream next: size</body><body package="MessagePack-Core" selector="readRaw32">readRaw32	| size |	size := MpPortableUtil default readUint32From: self readStream.	^self readStream next: size</body><body package="MessagePack-Core" selector="readTrue">readTrue	^true</body></methods><methods><class-id>MpDecoder</class-id> <category>accessing</category><body package="MessagePack-Core" selector="readStream">readStream	"Answer the value of readStream"	^ readStream</body><body package="MessagePack-Core" selector="readStream:">readStream: anObject	"Set the value of readStream"	readStream := anObject</body><body package="MessagePack-Core" selector="settings">settings	^settings ifNil: [settings := self settingsClass new]</body><body package="MessagePack-Core" selector="typeMapper">typeMapper	^ typeMapper ifNil: [typeMapper := self typeMapperClass on: self].</body></methods><methods><class-id>MpDecoder</class-id> <category>reading-integer</category><body package="MessagePack-Core" selector="readInt16">readInt16	^ MpPortableUtil default readInt16From: self readStream</body><body package="MessagePack-Core" selector="readInt32">readInt32	^ MpPortableUtil default readInt32From: self readStream</body><body package="MessagePack-Core" selector="readInt64">readInt64	^ MpPortableUtil default readInt64From: self readStream</body><body package="MessagePack-Core" selector="readInt8">readInt8	| val |	val := self readStream next.	val &gt;= 128 ifTrue: [^(256 - val) negated].	^val</body><body package="MessagePack-Core" selector="readUint16">readUint16	^ MpPortableUtil default readUint16From: self readStream</body><body package="MessagePack-Core" selector="readUint32">readUint32	^ MpPortableUtil default readUint32From: self readStream</body><body package="MessagePack-Core" selector="readUint64">readUint64	^ MpPortableUtil default readUint64From: self readStream</body><body package="MessagePack-Core" selector="readUint8">readUint8	^ self readStream next</body></methods><methods><class-id>MpDecoder</class-id> <category>reading-helper</category><body package="MessagePack-Core" selector="readArraySized:">readArraySized: size	| array |	array := self createArray: size.	1 to: size do: [:idx |		array at: idx put: (self readObject)	].	^array</body><body package="MessagePack-Core" selector="readMapSized:">readMapSized: size	| dic |	dic := self createDictionary: size.	size timesRepeat: [		dic at: self readObject put: self readObject	].	^dic</body><body package="MessagePack-Core" selector="readType">readType	^self readStream next</body></methods><methods><class-id>MpDecoder</class-id> <category>signaling error</category><body package="MessagePack-Core" selector="signalError">signalError	self signalError: 'Cannot decode'</body><body package="MessagePack-Core" selector="signalError:">signalError: message	^MpPortableUtil default signalException: (MpError decode messageText: message)</body></methods><methods><class-id>MpDecoder</class-id> <category>decoding</category><body package="MessagePack-Core" selector="decode">decode	self readStream atEnd ifTrue: [^self signalError: 'No data to read'].	^self read</body><body package="MessagePack-Core" selector="decode:">decode: byteArray	^self decodeFrom: byteArray readStream</body><body package="MessagePack-Core" selector="decodeFrom:">decodeFrom: aStream	self readStream: aStream "binary".	^self decode</body></methods><methods><class-id>MpDecoder</class-id> <category>factory</category><body package="MessagePack-Core" selector="createArray:">createArray: size	^Array new: size</body><body package="MessagePack-Core" selector="createDictionary:">createDictionary: size	^Dictionary new: size</body><body package="MessagePack-Core" selector="createOrderedCollection:">createOrderedCollection: size	^OrderedCollection new: size</body><body package="MessagePack-Core" selector="settingsClass">settingsClass	^MpSettings</body><body package="MessagePack-Core" selector="typeMapperClass">typeMapperClass	^MpDecodeTypeMapper</body></methods><methods><class-id>MpDecoder</class-id> <category>dispatching</category><body package="MessagePack-Core" selector="readObject">readObject	| type |	type := self readType.	^ self readObjectOf: type</body><body package="MessagePack-Core" selector="readObjectOf:">readObjectOf: type	^ self readObjectOf: type ifNotApplied: [self signalError]</body><body package="MessagePack-Core" selector="readObjectOf:ifNotApplied:">readObjectOf: type ifNotApplied: aBlock		type &lt;=16rBF ifTrue: [ | fixMapOrArray |		type &lt;= 16r7F ifTrue: [^ self readPositiveFixNum: type].		fixMapOrArray := type bitShift: -4.		fixMapOrArray = 2r1000 ifTrue: [^ self readFixMap: type].		fixMapOrArray = 2r1001 ifTrue: [^ self readFixArray: type].		^ self readFixRaw: type.	].	(type bitShift: -5) = 2r111 ifTrue: [^ self readNegativeFixNum: type].	^self typeMapper readObjectOf: type ifNotApplied: aBlock</body></methods><methods><class-id>MpDecoder</class-id> <category>stream-like</category><body package="MessagePack-Core" selector="atEnd">atEnd	^self readStream atEnd</body><body package="MessagePack-Core" selector="next">next	^self read</body></methods><methods><class-id>MpDecoder class</class-id> <category>actions</category><body package="MessagePack-Core" selector="decode:">decode: byteArray	^self new decode: byteArray</body><body package="MessagePack-Core" selector="decodeFrom:">decodeFrom: aStream	^self new decodeFrom: aStream</body><body package="MessagePack-Core" selector="on:">on: aStream	^self new readStream: aStream "binary"</body><body package="MessagePack-Core" selector="onBytes:">onBytes: byteArray	^self on: (ReadStream on: byteArray)</body></methods><methods><class-id>MpVwEncodeTypeMapper</class-id> <category>encode customization</category><body package="MessagePack-VW" selector="stringAsBytes">stringAsBytes	self actionMap at: ByteString put: #writeString:.	self actionMap at: TwoByteString put: #writeWideString:.	self actionMap at: FourByteString put: #writeWideString:.	self actionMap at: ByteSymbol put: #writeString:.	self actionMap at: TwoByteSymbol put: #writeWideString:.	self actionMap at: FourByteString put: #writeWideString:.</body></methods><methods><class-id>MpVwEncodeTypeMapper class</class-id> <category>actions for primitives</category><body package="MessagePack-VW" selector="defineDoubleActionTo:">defineDoubleActionTo: map	"Some dialect does not support Double"	map at: Double put: #writeDouble:</body><body package="MessagePack-VW" selector="defineFloatActionTo:">defineFloatActionTo: map	"Suppose 32 bit float - Some dialect does not support it"	map at: Float put: #writeFloat:</body></methods><methods><class-id>MpVwPortableUtil</class-id> <category>actions-stream</category><body package="MessagePack-VW" selector="readDoubleFrom:">readDoubleFrom: stream	| bytes |	bytes :=  stream next: 8.	UninterpretedBytes isBigEndian ifFalse: [ bytes := bytes reverse].	^ bytes changeClassTo: Double.</body><body package="MessagePack-VW" selector="readFloatFrom:">readFloatFrom: stream	"32 bit"	| bytes |	bytes := stream next: 4.	UninterpretedBytes isBigEndian ifFalse: [ bytes := bytes reverse].	^ bytes changeClassTo: Float.</body><body package="MessagePack-VW" selector="readInt16From:">readInt16From: stream	^ (UninterpretedBytes from: (stream next: 2)) shortAt: 1 bigEndian: true.</body><body package="MessagePack-VW" selector="readInt32From:">readInt32From: stream	^ (UninterpretedBytes from: (stream next: 4)) longAt: 1 bigEndian: true.</body><body package="MessagePack-VW" selector="readInt64From:">readInt64From: stream	^ (UninterpretedBytes from: (stream next: 8)) longLongAt: 1 bigEndian: true.</body><body package="MessagePack-VW" selector="readUint16From:">readUint16From: stream	^ (UninterpretedBytes from: (stream next: 2)) unsignedShortAt: 1 bigEndian: true.</body><body package="MessagePack-VW" selector="readUint32From:">readUint32From: stream	^ (UninterpretedBytes from: (stream next: 4)) unsignedLongAt: 1 bigEndian: true.</body><body package="MessagePack-VW" selector="readUint64From:">readUint64From: stream	^ (UninterpretedBytes from: (stream next: 8)) unsignedLongLongAt: 1 bigEndian: true.</body><body package="MessagePack-VW" selector="writeDouble:to:">writeDouble: value to: stream	value isBigEndian ifTrue: [		1 to: 8 do: [:idx | stream nextPut: (value basicAt: idx)]	] ifFalse: [		8 to: 1 by: -1 do: [:idx | stream nextPut: (value basicAt: idx)]	]</body><body package="MessagePack-VW" selector="writeFloat:to:">writeFloat: value to: stream	value isBigEndian ifTrue: [		1 to: 4 do: [:idx | stream nextPut: (value basicAt: idx)]	] ifFalse: [		4 to: 1 by: -1 do: [:idx | stream nextPut: (value basicAt: idx)]	]</body><body package="MessagePack-VW" selector="writeInt16:to:">writeInt16: value to: stream	| bytes |	bytes := UninterpretedBytes new: 2.	bytes shortAt: 1 put: value bigEndian: true.	stream nextPutAll: bytes asByteArray</body><body package="MessagePack-VW" selector="writeInt32:to:">writeInt32: value to: stream	| bytes |	bytes := UninterpretedBytes new: 4.	bytes longAt: 1 put: value bigEndian: true.	stream nextPutAll: bytes asByteArray</body><body package="MessagePack-VW" selector="writeInt64:to:">writeInt64: value to: stream	| bytes |	bytes := UninterpretedBytes new: 8.	bytes longLongAt: 1 put: value bigEndian: true.	stream nextPutAll: bytes asByteArray</body><body package="MessagePack-VW" selector="writeUint16:to:">writeUint16: value to: stream	| bytes |	bytes := UninterpretedBytes new: 2.	bytes unsignedShortAt: 1 put: value bigEndian: true.	stream nextPutAll: bytes asByteArray</body><body package="MessagePack-VW" selector="writeUint32:to:">writeUint32: value to: stream	| bytes |	bytes := UninterpretedBytes new: 4.	bytes unsignedLongAt: 1 put: value bigEndian: true.	stream nextPutAll: bytes asByteArray</body><body package="MessagePack-VW" selector="writeUint64:to:">writeUint64: value to: stream	| bytes |	bytes := UninterpretedBytes new: 8.	bytes unsignedLongLongAt: 1 put: value bigEndian: true.	stream nextPutAll: bytes asByteArray</body></methods><methods><class-id>MpVwPortableUtil</class-id> <category>factory</category><body package="MessagePack-VW" selector="encodeTypeMapperClass">encodeTypeMapperClass	^MpVwEncodeTypeMapper</body></methods><methods><class-id>MpVwPortableUtil</class-id> <category>actions</category><body package="MessagePack-VW" selector="bytesFromString:">bytesFromString: aString	^aString asByteArrayEncoding: #utf8</body><body package="MessagePack-VW" selector="signalException:">signalException: anException	^anException raise</body></methods><methods><class-id>MpVwPortableUtil</class-id> <category>defaults</category><body package="MessagePack-VW" selector="useFastBulkWrite">useFastBulkWrite	^ true</body></methods><methods><class-id>MpVwPortableUtil class</class-id> <category>class initialization</category><body package="MessagePack-VW" selector="initialize">initialize	"MpVwPortableUtil initialize"	super initialize.	MpPortableUtil dialectSpecificClass: self</body></methods><methods><class-id>Core.Integer</class-id> <category>*MessagePack-Core-optimization</category><body package="MessagePack-Core" selector="mpWriteSelector">mpWriteSelector	^#writeInteger:</body></methods><methods><class-id>Core.Array</class-id> <category>*MessagePack-Core-optimization</category><body package="MessagePack-Core" selector="mpWriteSelector">mpWriteSelector	self class == Array ifTrue: [^#writeArray:].	^nil</body></methods><methods><class-id>Core.Dictionary</class-id> <category>*MessagePack-Core-optimization</category><body package="MessagePack-Core" selector="mpWriteSelector">mpWriteSelector	self class == Dictionary ifTrue: [^#writeMap:].	^nil</body></methods><methods><class-id>Core.Behavior</class-id> <category>*MessagePack-Core-unpacking</category><body package="MessagePack-Core" selector="fromMessagePack:">fromMessagePack: bytes	^ MpDecoder decode: bytes</body></methods><methods><class-id>Core.ByteArray</class-id> <category>*MessagePack-Core-optimization</category><body package="MessagePack-Core" selector="mpWriteSelector">mpWriteSelector	self class == ByteArray ifTrue: [^#writeRawBytes:].	^nil</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>*MessagePack-Core-optimization</category><body package="MessagePack-Core" selector="mpWriteSelector">mpWriteSelector	^#writeNil:</body></methods><methods><class-id>Core.Double</class-id> <category>*MessagePack-Core-optimization</category><body package="MessagePack-Core" selector="mpWriteSelector">mpWriteSelector	^#writeDouble:</body></methods><methods><class-id>Core.False</class-id> <category>*MessagePack-Core-optimization</category><body package="MessagePack-Core" selector="mpWriteSelector">mpWriteSelector	^#writeFalse:</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>*MessagePack-Squeak-Core</category><body package="MessagePack-Core" selector="int64">int64	"Answer the next signed, 32-bit integer from this (binary) stream."	"Details: As a fast check for negative number, check the high bit of the first digit"	| n firstDigit |	n := firstDigit := self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	firstDigit &gt;= 128 ifTrue: [n := -16r10000000000000000 + n].  "decode negative 64-bit integer"	^ n</body><body package="MessagePack-Core" selector="int64:">int64: anInteger	"Store the given signed, 64-bit integer on this (binary) stream."	| n |	(anInteger &lt; -16r8000000000000000) | (anInteger &gt;= 16r8000000000000000)		ifTrue: [self error: 'outside 64-bit integer range'].	anInteger &lt; 0		ifTrue: [n := 16r10000000000000000 + anInteger]		ifFalse: [n := anInteger].	self nextPut: (n digitAt: 8).	self nextPut: (n digitAt: 7).	self nextPut: (n digitAt: 6).	self nextPut: (n digitAt: 5).	self nextPut: (n digitAt: 4).	self nextPut: (n digitAt: 3).	self nextPut: (n digitAt: 2).	self nextPut: (n digitAt: 1).</body><body package="MessagePack-Core" selector="uint64">uint64	"Answer the next unsigned, 64-bit integer from this (binary) stream."	| n |	n := self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	^ n</body><body package="MessagePack-Core" selector="uint64:">uint64: anInteger	"Store the given unsigned, 64-bit integer on this (binary) stream."	(anInteger &lt; 0) | (anInteger &gt;= 16r10000000000000000)		ifTrue: [self error: 'outside unsigned 64-bit integer range'].			self nextPut: (anInteger digitAt: 8).	self nextPut: (anInteger digitAt: 7).	self nextPut: (anInteger digitAt: 6).	self nextPut: (anInteger digitAt: 5).	self nextPut: (anInteger digitAt: 4).	self nextPut: (anInteger digitAt: 3).	self nextPut: (anInteger digitAt: 2).	self nextPut: (anInteger digitAt: 1).</body></methods><methods><class-id>Core.Object</class-id> <category>*MessagePack-Core-packing</category><body package="MessagePack-Core" selector="messagePacked">messagePacked	^ MpEncoder encode: self</body></methods><methods><class-id>Core.Object</class-id> <category>*MessagePack-Core-optimization</category><body package="MessagePack-Core" selector="mpWriteSelector">mpWriteSelector	^nil</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>*MessagePack-Core-optimization</category><body package="MessagePack-Core" selector="mpWriteSelector">mpWriteSelector	^nil</body></methods><methods><class-id>Core.True</class-id> <category>*MessagePack-Core-optimization</category><body package="MessagePack-Core" selector="mpWriteSelector">mpWriteSelector	^#writeTrue:</body></methods><initialize><class-id>MpTypeMapper</class-id></initialize><initialize><class-id>MpPortableUtil</class-id></initialize><initialize><class-id>MpVwPortableUtil</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>PositionableStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection position readLimit writeLimit policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>True</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>False</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>