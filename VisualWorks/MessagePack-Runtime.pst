<?xml version="1.0"?><st-source><!-- Name: MessagePack-RuntimeNotice: Copyright (C) 2011- Masashi UmezawaBundleName: MessagePack-RuntimeBundleStructure: a Store.BundleForParcelComment: ** MessagePack for VisualWorks **MessagePack is a compact binary serialization format (http://msgpack.org/)."Extremely efficient object serialization library for cross-language communication. It's like JSON, but very fast and small."This bundle includes minimal set for using MessagePack.(MessagePack-RPC is out of scope, currently).Copyright (C) 2011- Masashi UmezawaDisregardedPrerequisites: #()PackageName: MessagePack-RuntimeParcel: nilParcelName: MessagePack-RuntimePrerequisiteParcels: #(#('System-Name Spaces' ''))Version: 1.3Date: 1:18:16 PM June 3, 2011 --><time-stamp>From VisualWorks® NonCommercial, 7.7.1 of 2010年7月26日 on 2011年6月3日 at 13:18:16</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MpPortableUtil</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpVwPortableUtil</name><environment>Smalltalk</environment><super>MpPortableUtil</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Squeak-Core</category><attributes><package>MessagePack-VW</package></attributes></class><class><name>MpError</name><environment>Smalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpDecoder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readStream typeMapper settings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpTypeMapper</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actionMap </inst-vars><class-inst-vars>actionMap </class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpEncodeTypeMapper</name><environment>Smalltalk</environment><super>MpTypeMapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpVwEncodeTypeMapper</name><environment>Smalltalk</environment><super>MpEncodeTypeMapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Squeak-Core</category><attributes><package>MessagePack-VW</package></attributes></class><class><name>MpDecodeTypeMapper</name><environment>Smalltalk</environment><super>MpTypeMapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decoder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpSettings</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>settingsDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpMessagePack</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpEncoder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>writeStream typeMapper settings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>MpConstants</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><shared-variable><name>Default</name><environment>MpMessagePack</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>MessagePack-Core</package></attributes></shared-variable><shared-variable><name>DialectSpecificClass</name><environment>MpMessagePack</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>MessagePack-Core</package></attributes></shared-variable><shared-variable><name>Default</name><environment>MpPortableUtil</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>MessagePack-Core</package></attributes></shared-variable><shared-variable><name>DialectSpecificClass</name><environment>MpPortableUtil</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>MessagePack-Core</package></attributes></shared-variable><methods><class-id>MpPortableUtil</class-id> <category>actions-stream</category><body package="MessagePack-Core" selector="readDoubleFrom:">readDoubleFrom: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="readFloatFrom:">readFloatFrom: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="readInt16From:">readInt16From: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="readInt32From:">readInt32From: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="readInt64From:">readInt64From: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="readUint16From:">readUint16From: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="readUint32From:">readUint32From: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="readUint64From:">readUint64From: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="writeDouble:to:">writeDouble: value to: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="writeFloat:to:">writeFloat: value to: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="writeInt16:to:">writeInt16: value to: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="writeInt32:to:">writeInt32: value to: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="writeInt64:to:">writeInt64: value to: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="writeUint16:to:">writeUint16: value to: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="writeUint32:to:">writeUint32: value to: stream	self subclassResponsibility </body><body package="MessagePack-Core" selector="writeUint64:to:">writeUint64: value to: stream	self subclassResponsibility </body></methods><methods><class-id>MpPortableUtil</class-id> <category>actions</category><body package="MessagePack-Core" selector="signalException:">signalException: anException	"Ansi"	^anException signal</body></methods><methods><class-id>MpPortableUtil</class-id> <category>factory</category><body package="MessagePack-Core" selector="encodeTypeMapperClass">encodeTypeMapperClass	^MpEncodeTypeMapper</body></methods><methods><class-id>MpPortableUtil class</class-id> <category>class initialization</category><body package="MessagePack-Core" selector="initialize">initialize	Default := nil.	DialectSpecificClass := nil</body></methods><methods><class-id>MpPortableUtil class</class-id> <category>instance creation</category><body package="MessagePack-Core" selector="default">default	^Default ifNil: [Default := self dialectSpecificClass new]</body></methods><methods><class-id>MpPortableUtil class</class-id> <category>factory</category><body package="MessagePack-Core" selector="dialectSpecificClass">dialectSpecificClass	^DialectSpecificClass ifNil: [DialectSpecificClass := self subclasses at: 1]</body><body package="MessagePack-Core" selector="dialectSpecificClass:">dialectSpecificClass: aClass	DialectSpecificClass := aClass</body></methods><methods><class-id>MpVwPortableUtil</class-id> <category>factory</category><body package="MessagePack-VW" selector="encodeTypeMapperClass">encodeTypeMapperClass	^MpVwEncodeTypeMapper</body></methods><methods><class-id>MpVwPortableUtil</class-id> <category>actions-stream</category><body package="MessagePack-VW" selector="readDoubleFrom:">readDoubleFrom: stream	| bytes |	bytes :=  stream next: 8.	UninterpretedBytes isBigEndian ifFalse: [ bytes := bytes reverse].	^ bytes changeClassTo: Double.</body><body package="MessagePack-VW" selector="readFloatFrom:">readFloatFrom: stream	"32 bit"	| bytes |	bytes := stream next: 4.	UninterpretedBytes isBigEndian ifFalse: [ bytes := bytes reverse].	^ bytes changeClassTo: Float.</body><body package="MessagePack-VW" selector="readInt16From:">readInt16From: stream	^ (UninterpretedBytes from: (stream next: 2)) shortAt: 1 bigEndian: true.</body><body package="MessagePack-VW" selector="readInt32From:">readInt32From: stream	^ (UninterpretedBytes from: (stream next: 4)) longAt: 1 bigEndian: true.</body><body package="MessagePack-VW" selector="readInt64From:">readInt64From: stream	^ (UninterpretedBytes from: (stream next: 8)) longLongAt: 1 bigEndian: true.</body><body package="MessagePack-VW" selector="readUint16From:">readUint16From: stream	^ (UninterpretedBytes from: (stream next: 2)) unsignedShortAt: 1 bigEndian: true.</body><body package="MessagePack-VW" selector="readUint32From:">readUint32From: stream	^ (UninterpretedBytes from: (stream next: 4)) unsignedLongAt: 1 bigEndian: true.</body><body package="MessagePack-VW" selector="readUint64From:">readUint64From: stream	^ (UninterpretedBytes from: (stream next: 8)) unsignedLongLongAt: 1 bigEndian: true.</body><body package="MessagePack-VW" selector="writeDouble:to:">writeDouble: value to: stream	value isBigEndian ifTrue: [		1 to: 8 do: [:idx | stream nextPut: (value basicAt: idx)]	] ifFalse: [		8 to: 1 by: -1 do: [:idx | stream nextPut: (value basicAt: idx)]	]</body><body package="MessagePack-VW" selector="writeFloat:to:">writeFloat: value to: stream	value isBigEndian ifTrue: [		1 to: 4 do: [:idx | stream nextPut: (value basicAt: idx)]	] ifFalse: [		4 to: 1 by: -1 do: [:idx | stream nextPut: (value basicAt: idx)]	]</body><body package="MessagePack-VW" selector="writeInt16:to:">writeInt16: value to: stream	| bytes |	bytes := UninterpretedBytes new: 2.	bytes shortAt: 1 put: value bigEndian: true.	stream nextPutAll: bytes asByteArray</body><body package="MessagePack-VW" selector="writeInt32:to:">writeInt32: value to: stream	| bytes |	bytes := UninterpretedBytes new: 4.	bytes longAt: 1 put: value bigEndian: true.	stream nextPutAll: bytes asByteArray</body><body package="MessagePack-VW" selector="writeInt64:to:">writeInt64: value to: stream	| bytes |	bytes := UninterpretedBytes new: 8.	bytes longLongAt: 1 put: value bigEndian: true.	stream nextPutAll: bytes asByteArray</body><body package="MessagePack-VW" selector="writeUint16:to:">writeUint16: value to: stream	| bytes |	bytes := UninterpretedBytes new: 2.	bytes unsignedShortAt: 1 put: value bigEndian: true.	stream nextPutAll: bytes asByteArray</body><body package="MessagePack-VW" selector="writeUint32:to:">writeUint32: value to: stream	| bytes |	bytes := UninterpretedBytes new: 4.	bytes unsignedLongAt: 1 put: value bigEndian: true.	stream nextPutAll: bytes asByteArray</body><body package="MessagePack-VW" selector="writeUint64:to:">writeUint64: value to: stream	| bytes |	bytes := UninterpretedBytes new: 8.	bytes unsignedLongLongAt: 1 put: value bigEndian: true.	stream nextPutAll: bytes asByteArray</body></methods><methods><class-id>MpVwPortableUtil</class-id> <category>actions</category><body package="MessagePack-VW" selector="signalException:">signalException: anException	^anException raise</body></methods><methods><class-id>MpVwPortableUtil class</class-id> <category>class initialization</category><body package="MessagePack-VW" selector="initialize">initialize	"MpVwPortableUtil initialize"	super initialize.	MpPortableUtil dialectSpecificClass: self</body></methods><methods><class-id>MpError</class-id> <category>accessing</category><body package="MessagePack-Core" selector="type">type	"Answer the value of type"	^ type</body><body package="MessagePack-Core" selector="type:">type: anObject	"Set the value of type"	type := anObject</body></methods><methods><class-id>MpError class</class-id> <category>instance creation</category><body package="MessagePack-Core" selector="decode">decode	^self new type: #decode</body><body package="MessagePack-Core" selector="encode">encode	^self new type: #encode</body></methods><methods><class-id>MpDecoder</class-id> <category>decoding</category><body package="MessagePack-Core" selector="decode">decode	self readStream atEnd ifTrue: [^self signalError: 'No data to read'].	^self read</body><body package="MessagePack-Core" selector="decode:">decode: byteArray	^self decodeFrom: byteArray readStream</body><body package="MessagePack-Core" selector="decodeFrom:">decodeFrom: aStream	self readStream: aStream "binary".	^self decode</body></methods><methods><class-id>MpDecoder</class-id> <category>reading-helper</category><body package="MessagePack-Core" selector="readArraySized:">readArraySized: size	| array |	array := self createArray: size.	1 to: size do: [:idx |		array at: idx put: (self readObject)	].	^array</body><body package="MessagePack-Core" selector="readMapSized:">readMapSized: size	| dic |	dic := self createDictionary: size.	1 to: size do: [:idx |		dic at: self readObject put: self readObject	].	^dic</body><body package="MessagePack-Core" selector="readType">readType	^self readStream next</body></methods><methods><class-id>MpDecoder</class-id> <category>accessing</category><body package="MessagePack-Core" selector="readStream">readStream	"Answer the value of readStream"	^ readStream</body><body package="MessagePack-Core" selector="readStream:">readStream: anObject	"Set the value of readStream"	readStream := anObject</body><body package="MessagePack-Core" selector="settings">settings	^settings ifNil: [settings := self settingsClass new]</body><body package="MessagePack-Core" selector="typeMapper">typeMapper	^ typeMapper ifNil: [typeMapper := self typeMapperClass on: self].</body></methods><methods><class-id>MpDecoder</class-id> <category>reading</category><body package="MessagePack-Core" selector="read">read	^self readObject.	</body><body package="MessagePack-Core" selector="readArray16">readArray16	| size |	size := MpPortableUtil default readUint16From: self readStream.	^ self readArraySized: size</body><body package="MessagePack-Core" selector="readArray32">readArray32	| size |	size := MpPortableUtil default readUint32From: self readStream.	^ self readArraySized: size</body><body package="MessagePack-Core" selector="readDouble">readDouble	"64 bit"	^MpPortableUtil default readDoubleFrom: self readStream</body><body package="MessagePack-Core" selector="readFalse">readFalse	^false</body><body package="MessagePack-Core" selector="readFixArray:">readFixArray: firstByte	| size |	size := (2r10010000 bitXor: firstByte).	^ self readArraySized: size</body><body package="MessagePack-Core" selector="readFixMap:">readFixMap: firstByte	| size |	size := (2r10000000 bitXor: firstByte).	^self readMapSized: size</body><body package="MessagePack-Core" selector="readFixRaw:">readFixRaw: firstByte	| size |	size := (2r10100000 bitXor: firstByte).	^self readStream next: size</body><body package="MessagePack-Core" selector="readFloat">readFloat	"32 bit"	^MpPortableUtil default readFloatFrom: self readStream</body><body package="MessagePack-Core" selector="readMap16">readMap16	| size |	size := MpPortableUtil default readUint16From: self readStream.	^ self readMapSized: size</body><body package="MessagePack-Core" selector="readMap32">readMap32	| size |	size := MpPortableUtil default readUint32From: self readStream.	^ self readMapSized: size</body><body package="MessagePack-Core" selector="readNegativeFixNum:">readNegativeFixNum: firstByte	| val |	val := (2r11100000 bitXor: firstByte).	^ val = 0 ifTrue: [-32] ifFalse: [val negated]	</body><body package="MessagePack-Core" selector="readNil">readNil	^nil</body><body package="MessagePack-Core" selector="readPositiveFixNum:">readPositiveFixNum: firstByte	"0 - 127"	^ firstByte</body><body package="MessagePack-Core" selector="readRaw16">readRaw16	| size |	size := MpPortableUtil default readUint16From: self readStream.	^self readStream next: size</body><body package="MessagePack-Core" selector="readRaw32">readRaw32	| size |	size := MpPortableUtil default readUint32From: self readStream.	^self readStream next: size</body><body package="MessagePack-Core" selector="readTrue">readTrue	^true</body></methods><methods><class-id>MpDecoder</class-id> <category>reading-integer</category><body package="MessagePack-Core" selector="readInt16">readInt16	^ MpPortableUtil default readInt16From: self readStream</body><body package="MessagePack-Core" selector="readInt32">readInt32	^ MpPortableUtil default readInt32From: self readStream</body><body package="MessagePack-Core" selector="readInt64">readInt64	^ MpPortableUtil default readInt64From: self readStream</body><body package="MessagePack-Core" selector="readInt8">readInt8	| val |	val := self readStream next.	val &gt;= 128 ifTrue: [^(256 - val) negated].	^val</body><body package="MessagePack-Core" selector="readUint16">readUint16	^ MpPortableUtil default readUint16From: self readStream</body><body package="MessagePack-Core" selector="readUint32">readUint32	^ MpPortableUtil default readUint32From: self readStream</body><body package="MessagePack-Core" selector="readUint64">readUint64	^ MpPortableUtil default readUint64From: self readStream</body><body package="MessagePack-Core" selector="readUint8">readUint8	^ self readStream next</body></methods><methods><class-id>MpDecoder</class-id> <category>factory</category><body package="MessagePack-Core" selector="createArray:">createArray: size	^Array new: size</body><body package="MessagePack-Core" selector="createDictionary:">createDictionary: size	^Dictionary new: size</body><body package="MessagePack-Core" selector="createOrderedCollection:">createOrderedCollection: size	^OrderedCollection new: size</body><body package="MessagePack-Core" selector="settingsClass">settingsClass	^MpSettings</body><body package="MessagePack-Core" selector="typeMapperClass">typeMapperClass	^MpDecodeTypeMapper</body></methods><methods><class-id>MpDecoder</class-id> <category>dispatching</category><body package="MessagePack-Core" selector="readObject">readObject	| type |	type := self readType.	^ self readObjectOf: type	</body><body package="MessagePack-Core" selector="readObjectOf:">readObjectOf: type	^ self readObjectOf: type ifNotApplied: [self signalError]		</body><body package="MessagePack-Core" selector="readObjectOf:ifNotApplied:">readObjectOf: type ifNotApplied: aBlock	type &lt;=16rbf ifTrue: [		(type between: 16r00 and: 16r7f) ifTrue: [^ self readPositiveFixNum: type].		(type between: 16r80 and: 16r8f) ifTrue: [^ self readFixMap: type].		(type between: 16r90 and: 16r9f) ifTrue: [^ self readFixArray: type].		^ self readFixRaw: type.	].	^self typeMapper readObjectOf: type ifNotApplied: [		(type between: 16re0 and: 16rff) ifTrue: [^ self readNegativeFixNum: type].		aBlock value	]</body></methods><methods><class-id>MpDecoder</class-id> <category>signaling error</category><body package="MessagePack-Core" selector="signalError">signalError	self signalError: 'Cannot decode'</body><body package="MessagePack-Core" selector="signalError:">signalError: message	^MpPortableUtil default signalException: (MpError decode messageText: message) </body></methods><methods><class-id>MpDecoder class</class-id> <category>actions</category><body package="MessagePack-Core" selector="decode:">decode: byteArray	^self new decode: byteArray</body><body package="MessagePack-Core" selector="decodeFrom:">decodeFrom: aStream	^self new decodeFrom: aStream</body><body package="MessagePack-Core" selector="on:">on: aStream	^self new readStream: aStream "binary"</body><body package="MessagePack-Core" selector="onBytes:">onBytes: byteArray	^self on: (ReadStream on: byteArray)</body></methods><methods><class-id>MpTypeMapper</class-id> <category>initialization</category><body package="MessagePack-Core" selector="initActionMaps">initActionMaps	"override for custom mapping"	actionMap := nil</body></methods><methods><class-id>MpTypeMapper</class-id> <category>accessing</category><body package="MessagePack-Core" selector="actionMap">actionMap	^ actionMap ifNil: [actionMap := IdentityDictionary new]</body><body package="MessagePack-Core" selector="defaultActionMap">defaultActionMap	^ self class actionMap</body></methods><methods><class-id>MpTypeMapper class</class-id> <category>actions for compounds</category><body package="MessagePack-Core" selector="defineCompoundsActionsTo:">defineCompoundsActionsTo: map	"override"</body></methods><methods><class-id>MpTypeMapper class</class-id> <category>actions for primitives</category><body package="MessagePack-Core" selector="definePrimitivesActionsTo:">definePrimitivesActionsTo: map	"override"</body></methods><methods><class-id>MpTypeMapper class</class-id> <category>factory</category><body package="MessagePack-Core" selector="createActionMap">createActionMap	| map |	map := IdentityDictionary new.	self definePrimitivesActionsTo: map.	self defineCompoundsActionsTo: map.	^map</body></methods><methods><class-id>MpTypeMapper class</class-id> <category>class initialization</category><body package="MessagePack-Core" selector="initialize">initialize	"self initialize"	actionMap  := nil.	self actionMap	</body><body package="MessagePack-Core" selector="initializeAll">initializeAll	"self initializeAll"	self allSubclasses do: [:each | each initialize]</body></methods><methods><class-id>MpTypeMapper class</class-id> <category>accessing</category><body package="MessagePack-Core" selector="actionMap">actionMap	^ actionMap ifNil: [actionMap := self createActionMap]</body></methods><methods><class-id>MpEncodeTypeMapper</class-id> <category>actions</category><body package="MessagePack-Core" selector="writeObject:ifNotApplied:">writeObject: anObject ifNotApplied: aBlock 	| actionSelector |	actionMap		ifNotNil: [actionSelector := self actionMap at: anObject class ifAbsent: [].			actionSelector ifNotNil: [^ self encoder perform: actionSelector with: anObject]].			actionSelector := self defaultActionMap				at: anObject class				ifAbsent: [^ aBlock value].	^ self encoder perform: actionSelector with: anObject</body></methods><methods><class-id>MpEncodeTypeMapper</class-id> <category>accessing</category><body package="MessagePack-Core" selector="encoder">encoder	"Answer the value of encoder"	^ encoder</body><body package="MessagePack-Core" selector="encoder:">encoder: anObject	"Set the value of encoder"	encoder := anObject</body></methods><methods><class-id>MpEncodeTypeMapper class</class-id> <category>actions for compounds</category><body package="MessagePack-Core" selector="defineArrayActionTo:">defineArrayActionTo: map	map at: Array put: #writeArray:.</body><body package="MessagePack-Core" selector="defineCompoundsActionsTo:">defineCompoundsActionsTo: map	self defineArrayActionTo: map.	self defineMapActionTo: map.	</body><body package="MessagePack-Core" selector="defineMapActionTo:">defineMapActionTo: map		map at: Dictionary put: #writeMap:.	"map at: IdentityDictionary put: #writeDictionary:"		</body></methods><methods><class-id>MpEncodeTypeMapper class</class-id> <category>actions for primitives</category><body package="MessagePack-Core" selector="defineDoubleActionTo:">defineDoubleActionTo: map	"Some dialect does not support Double"	"map at: Double put: #writeDouble:"</body><body package="MessagePack-Core" selector="defineFalseActionTo:">defineFalseActionTo: map	map at: False put: #writeFalse:</body><body package="MessagePack-Core" selector="defineFloatActionTo:">defineFloatActionTo: map	"Suppose 32 bit float - Some dialect does not support it"	"map at: Float put: #writeFloat:"</body><body package="MessagePack-Core" selector="defineIntegerActionTo:">defineIntegerActionTo: map	Integer allSubclasses do: [:each |		map at: each put: #writeInteger:	]</body><body package="MessagePack-Core" selector="defineNilActionTo:">defineNilActionTo: map	map at: UndefinedObject put: #writeNil:</body><body package="MessagePack-Core" selector="definePrimitivesActionsTo:">definePrimitivesActionsTo: map	self defineRawBytesActionTo: map.	self defineIntegerActionTo: map.	self defineFloatActionTo: map.	self defineDoubleActionTo: map.	self defineNilActionTo: map.	self defineTrueActionTo: map.	self defineFalseActionTo: map.</body><body package="MessagePack-Core" selector="defineRawBytesActionTo:">defineRawBytesActionTo: map	map at: ByteArray put: #writeRawBytes:</body><body package="MessagePack-Core" selector="defineTrueActionTo:">defineTrueActionTo: map	map at: True put: #writeTrue:</body></methods><methods><class-id>MpEncodeTypeMapper class</class-id> <category>instance creation</category><body package="MessagePack-Core" selector="on:">on: bertEncoder 	^ self new encoder: bertEncoder;		 initActionMaps;		 yourself</body></methods><methods><class-id>MpVwEncodeTypeMapper class</class-id> <category>actions for primitives</category><body package="MessagePack-VW" selector="defineDoubleActionTo:">defineDoubleActionTo: map	"Some dialect does not support Double"	map at: Double put: #writeDouble:</body><body package="MessagePack-VW" selector="defineFloatActionTo:">defineFloatActionTo: map	"Suppose 32 bit float - Some dialect does not support it"	map at: Float put: #writeFloat:</body></methods><methods><class-id>MpDecodeTypeMapper</class-id> <category>accessing</category><body package="MessagePack-Core" selector="decoder">decoder	"Answer the value of decoder"	^ decoder</body><body package="MessagePack-Core" selector="decoder:">decoder: anObject	"Set the value of decoder"	decoder := anObject</body></methods><methods><class-id>MpDecodeTypeMapper</class-id> <category>actions</category><body package="MessagePack-Core" selector="readObjectOf:ifNotApplied:">readObjectOf: typeCode ifNotApplied: aBlock 	| actionSelector |		actionMap		ifNotNil: [actionSelector := self actionMap at: typeCode ifAbsent: [].			actionSelector ifNotNil: [^ self decoder perform: actionSelector]].		actionSelector := self defaultActionMap				at: typeCode				ifAbsent: [^ aBlock value].	^ self decoder perform: actionSelector</body></methods><methods><class-id>MpDecodeTypeMapper class</class-id> <category>actions for compounds</category><body package="MessagePack-Core" selector="defineArrayActionTo:">defineArrayActionTo: map	map at: MpConstants array16 put: #readArray16.	map at: MpConstants array32 put: #readArray32.		</body><body package="MessagePack-Core" selector="defineCompoundsActionsTo:">defineCompoundsActionsTo: map	self defineArrayActionTo: map.	self defineMapActionTo: map.</body><body package="MessagePack-Core" selector="defineMapActionTo:">defineMapActionTo: map		map at: MpConstants map16 put: #readMap16.	map at: MpConstants map32 put: #readMap32.</body></methods><methods><class-id>MpDecodeTypeMapper class</class-id> <category>actions for primitives</category><body package="MessagePack-Core" selector="defineDoubleActionTo:">defineDoubleActionTo: map	map at: MpConstants double put: #readDouble</body><body package="MessagePack-Core" selector="defineFalseActionTo:">defineFalseActionTo: map	map at: MpConstants false put: #readFalse</body><body package="MessagePack-Core" selector="defineFloatActionTo:">defineFloatActionTo: map	map at: MpConstants float put: #readFloat</body><body package="MessagePack-Core" selector="defineIntegerActionTo:">defineIntegerActionTo: map	map at: MpConstants int8 put: #readInt8.	map at: MpConstants int16 put: #readInt16.	map at: MpConstants int32 put: #readInt32.	map at: MpConstants int64 put: #readInt64.</body><body package="MessagePack-Core" selector="defineNilActionTo:">defineNilActionTo: map	map at: MpConstants nil put: #readNil</body><body package="MessagePack-Core" selector="definePrimitivesActionsTo:">definePrimitivesActionsTo: map	self defineNilActionTo: map.	self defineFalseActionTo: map.	self defineTrueActionTo: map.	self defineFloatActionTo: map.	self defineDoubleActionTo: map.	self defineUnsignedIntegerActionTo: map.	self defineIntegerActionTo: map.	self defineRawBytesActionTo: map.	</body><body package="MessagePack-Core" selector="defineRawBytesActionTo:">defineRawBytesActionTo: map	map at: MpConstants raw16 put: #readRaw16.	map at: MpConstants raw32 put: #readRaw32.</body><body package="MessagePack-Core" selector="defineTrueActionTo:">defineTrueActionTo: map	map at: MpConstants true put: #readTrue</body><body package="MessagePack-Core" selector="defineUnsignedIntegerActionTo:">defineUnsignedIntegerActionTo: map	map at: MpConstants uint8 put: #readUint8.	map at: MpConstants uint16 put: #readUint16.	map at: MpConstants uint32 put: #readUint32.	map at: MpConstants uint64 put: #readUint64.</body></methods><methods><class-id>MpDecodeTypeMapper class</class-id> <category>instance creation</category><body package="MessagePack-Core" selector="on:">on: bertDecoder 	^ self new decoder: bertDecoder;		 initActionMaps;		 yourself</body></methods><methods><class-id>MpSettings</class-id> <category>actions-dictionary</category><body package="MessagePack-Core" selector="at:">at: key	^self settingsDict at: key</body><body package="MessagePack-Core" selector="at:ifAbsent:">at: key ifAbsent: aBlock	^self settingsDict at: key ifAbsent: aBlock</body><body package="MessagePack-Core" selector="at:ifAbsentPut:">at: key ifAbsentPut: aBlock	^self settingsDict at: key ifAbsentPut: aBlock</body><body package="MessagePack-Core" selector="at:put:">at: key put: value	^self settingsDict at: key put: value</body><body package="MessagePack-Core" selector="includesKey:">includesKey: key	^self settingsDict includesKey: key</body><body package="MessagePack-Core" selector="keys">keys	^self settingsDict keys</body></methods><methods><class-id>MpSettings</class-id> <category>accessing-private</category><body package="MessagePack-Core" selector="settingsDict">settingsDict	^ settingsDict ifNil: [settingsDict := IdentityDictionary new]</body></methods><methods><class-id>MpSettings</class-id> <category>class initialization</category><body package="MessagePack-Core" selector="initialize">initialize	settingsDict := nil</body></methods><methods><class-id>MpSettings</class-id> <category>accessing</category><body package="MessagePack-Core" selector="defaultStreamSize">defaultStreamSize	^self at: #defaultStreamSize ifAbsentPut: [1024]</body><body package="MessagePack-Core" selector="defaultStreamSize:">defaultStreamSize: anInteger	^self at: #defaultStreamSize put: anInteger</body></methods><methods><class-id>MpMessagePack class</class-id> <category>utilities</category><body package="MessagePack-Core" selector="pack:">pack: anObject	^ MpEncoder encode: anObject</body><body package="MessagePack-Core" selector="packUnpack:">packUnpack: anObject	^self unpack: (self pack: anObject)</body><body package="MessagePack-Core" selector="unpack:">unpack: aByteArray	^ MpDecoder decode: aByteArray</body></methods><methods><class-id>MpEncoder</class-id> <category>writing-helper</category><body package="MessagePack-Core" selector="writeArraySize:">writeArraySize: size	size &lt; 16r10 ifTrue: [^ self writeStream nextPut: (2r10010000 bitOr: size)].	size &lt; 16r10000  ifTrue: [		self writeStream nextPut: MpConstants array16.		^MpPortableUtil default writeUint16: size to: self writeStream	].	size &lt; 16r100000000  ifTrue: [		self writeStream nextPut: MpConstants array32.		^MpPortableUtil default writeUint32: size to: self writeStream	].		self signalError</body><body package="MessagePack-Core" selector="writeInt16:">writeInt16: value	self writeStream nextPut: MpConstants int16.	MpPortableUtil default writeInt16: value to: self writeStream</body><body package="MessagePack-Core" selector="writeInt32:">writeInt32: value	self writeStream nextPut: MpConstants int32.	MpPortableUtil default writeInt32: value to: self writeStream</body><body package="MessagePack-Core" selector="writeInt64:">writeInt64: value	self writeStream nextPut: MpConstants int64.	MpPortableUtil default writeInt64: value to: self writeStream</body><body package="MessagePack-Core" selector="writeInt8:">writeInt8: value	| val |	self writeStream nextPut: MpConstants int8.	val := value &lt; 0 ifTrue: [256 + value] ifFalse: [value].	self writeStream nextPut: val</body><body package="MessagePack-Core" selector="writeMapSize:">writeMapSize: size	size &lt; 16r10 ifTrue: [^ self writeStream nextPut: (2r10000000 bitOr: size)].	size &lt; 16r10000  ifTrue: [		self writeStream nextPut: MpConstants map16.		^MpPortableUtil default writeUint16: size to: self writeStream	].	size &lt; 16r100000000  ifTrue: [		self writeStream nextPut: MpConstants map32.		^MpPortableUtil default writeUint32: size to: self writeStream	].		self signalError</body><body package="MessagePack-Core" selector="writeNegativeFixNum:">writeNegativeFixNum: number	"-32 to -1"	| val |	val := number digitAt: 1.	self writeStream nextPut: (2r11100000 bitOr: val)	</body><body package="MessagePack-Core" selector="writePositiveFixNum:">writePositiveFixNum: number	self writeStream nextPut: number	</body><body package="MessagePack-Core" selector="writeRawBytesSize:">writeRawBytesSize: size	size &lt; 16r10 ifTrue: [^ self writeStream nextPut: (2r10100000 bitOr: size)].	size &lt; 16r10000  ifTrue: [		self writeStream nextPut: MpConstants raw16.		^MpPortableUtil default writeUint16: size to: self writeStream	].	size &lt; 16r100000000  ifTrue: [		self writeStream nextPut: MpConstants raw32.		^MpPortableUtil default writeUint32: size to: self writeStream	].		self signalError</body><body package="MessagePack-Core" selector="writeUint16:">writeUint16: value	self writeStream nextPut: MpConstants uint16.	MpPortableUtil default writeUint16: value to: self writeStream</body><body package="MessagePack-Core" selector="writeUint32:">writeUint32: value	self writeStream nextPut: MpConstants uint32.	MpPortableUtil default writeUint32: value to: self writeStream</body><body package="MessagePack-Core" selector="writeUint64:">writeUint64: value	self writeStream nextPut: MpConstants uint64.	MpPortableUtil default writeUint64: value to: self writeStream</body><body package="MessagePack-Core" selector="writeUint8:">writeUint8: value	self writeStream nextPut: MpConstants uint8.	self writeStream nextPut: value</body></methods><methods><class-id>MpEncoder</class-id> <category>writing</category><body package="MessagePack-Core" selector="writeArray:">writeArray: array	| size |	size := array size.	self writeArraySize: size.	array do: [:each | self writeObject: each].	</body><body package="MessagePack-Core" selector="writeDouble:">writeDouble: aFloat	self writeStream nextPut: MpConstants double.	MpPortableUtil default writeDouble: aFloat to: self writeStream</body><body package="MessagePack-Core" selector="writeFalse:">writeFalse: ignore	self writeStream nextPut: MpConstants false</body><body package="MessagePack-Core" selector="writeFloat:">writeFloat: aFloat	self writeStream nextPut: MpConstants float.	MpPortableUtil default writeFloat: aFloat to: self writeStream</body><body package="MessagePack-Core" selector="writeInteger:">writeInteger: anInteger 	(anInteger between: 0 and: 127)		ifTrue: [^self writePositiveFixNum: anInteger].			(anInteger between: -32 and: -1)		ifTrue: [^self writeNegativeFixNum: anInteger].		anInteger &gt;= 128 ifTrue: [		anInteger &lt;= 255 ifTrue: [^self writeUint8: anInteger].		anInteger &lt;= 65535 ifTrue: [^self writeUint16: anInteger].		anInteger &lt;= 4294967295 ifTrue: [^self writeUint32: anInteger].		anInteger &lt;= 18446744073709551615 ifTrue: [^self writeUint64: anInteger].	].		anInteger &gt;= -128 ifTrue: [^self writeInt8: anInteger].	anInteger &gt;= -32768 ifTrue: [^self writeInt16: anInteger].	anInteger &gt;= -2147483648 ifTrue: [^self writeInt32: anInteger].	anInteger &gt;= -9223372036854775808 ifTrue: [^self writeInt64: anInteger].		self signalError</body><body package="MessagePack-Core" selector="writeMap:">writeMap: aDictionary	| size |	size := aDictionary size.	self writeMapSize: size.	aDictionary keysAndValuesDo: [:key :value | self writeObject: key; writeObject: value].</body><body package="MessagePack-Core" selector="writeNil:">writeNil: ignore	self writeStream nextPut: MpConstants nil</body><body package="MessagePack-Core" selector="writeRawBytes:">writeRawBytes: bytes	| size |	size := bytes size.	self writeRawBytesSize: size.	self writeStream nextPutAll: bytes</body><body package="MessagePack-Core" selector="writeTrue:">writeTrue: ignore	self writeStream nextPut: MpConstants true</body></methods><methods><class-id>MpEncoder</class-id> <category>dispatching</category><body package="MessagePack-Core" selector="writeObject:">writeObject: anObject 	^self		writeObject: anObject		ifNotApplied: [self signalError]</body><body package="MessagePack-Core" selector="writeObject:ifNotApplied:">writeObject: anObject ifNotApplied: aBlock 	^self typeMapper writeObject: anObject ifNotApplied: aBlock</body></methods><methods><class-id>MpEncoder</class-id> <category>factory</category><body package="MessagePack-Core" selector="settingsClass">settingsClass	^MpSettings</body></methods><methods><class-id>MpEncoder</class-id> <category>accessing</category><body package="MessagePack-Core" selector="contents">contents	^self writeStream contents</body><body package="MessagePack-Core" selector="settings">settings	^settings ifNil: [settings := self settingsClass new]</body><body package="MessagePack-Core" selector="typeMapper">typeMapper	^ typeMapper ifNil: [typeMapper := self typeMapperClass on: self].</body><body package="MessagePack-Core" selector="typeMapperClass">typeMapperClass	^MpPortableUtil default encodeTypeMapperClass</body><body package="MessagePack-Core" selector="writeStream">writeStream	writeStream isNil		ifTrue: [writeStream := WriteStream						on: (ByteArray new: self settings defaultStreamSize)].	^ writeStream</body><body package="MessagePack-Core" selector="writeStream:">writeStream: anObject	"Set the value of writeStream"	writeStream := anObject</body></methods><methods><class-id>MpEncoder</class-id> <category>encoding</category><body package="MessagePack-Core" selector="encode:">encode: anObject	^self encode: anObject on: self writeStream</body><body package="MessagePack-Core" selector="encode:on:">encode: anObject on: aStream	self write: anObject on: aStream.	^self contents.</body><body package="MessagePack-Core" selector="write:on:">write: anObject on: aStream	self writeStream: aStream "binary".	self writeObject: anObject</body></methods><methods><class-id>MpEncoder</class-id> <category>signaling error</category><body package="MessagePack-Core" selector="signalError">signalError	self signalError: 'Cannot encode'</body><body package="MessagePack-Core" selector="signalError:">signalError: message	^MpPortableUtil default signalException: (MpError encode messageText: message) </body></methods><methods><class-id>MpEncoder class</class-id> <category>actions</category><body package="MessagePack-Core" selector="encode:">encode: anObject 	^self new encode: anObject</body><body package="MessagePack-Core" selector="encode:on:">encode: anObject on: aStream	^self new encode: anObject on: aStream</body><body package="MessagePack-Core" selector="on:">on: aStream	^self new writeStream: aStream; yourself</body><body package="MessagePack-Core" selector="onBytes:">onBytes: byteArray	^self on: (WriteStream on: byteArray).</body></methods><methods><class-id>MpConstants class</class-id> <category>typecodes</category><body package="MessagePack-Core" selector="array16">array16	^16rdc</body><body package="MessagePack-Core" selector="array32">array32	^16rdd</body><body package="MessagePack-Core" selector="double">double	^16rcb</body><body package="MessagePack-Core" selector="false">false	^16rc2</body><body package="MessagePack-Core" selector="float">float	^16rca</body><body package="MessagePack-Core" selector="int16">int16	^16rd1</body><body package="MessagePack-Core" selector="int32">int32	^16rd2</body><body package="MessagePack-Core" selector="int64">int64	^16rd3</body><body package="MessagePack-Core" selector="int8">int8	^16rd0</body><body package="MessagePack-Core" selector="map16">map16	^16rde</body><body package="MessagePack-Core" selector="map32">map32	^16rdf</body><body package="MessagePack-Core" selector="nil">nil	^16rc0</body><body package="MessagePack-Core" selector="raw16">raw16	^16rda</body><body package="MessagePack-Core" selector="raw32">raw32	^16rdb</body><body package="MessagePack-Core" selector="true">true	^16rc3</body><body package="MessagePack-Core" selector="uint16">uint16	^16rcd</body><body package="MessagePack-Core" selector="uint32">uint32	^16rce</body><body package="MessagePack-Core" selector="uint64">uint64	^16rcf</body><body package="MessagePack-Core" selector="uint8">uint8	^16rcc</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>*MessagePack-Squeak-Core</category><body package="MessagePack-Core" selector="int64">int64	"Answer the next signed, 32-bit integer from this (binary) stream."	"Details: As a fast check for negative number, check the high bit of the first digit"	| n firstDigit |	n := firstDigit := self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	firstDigit &gt;= 128 ifTrue: [n := -16r10000000000000000 + n].  "decode negative 64-bit integer"	^ n</body><body package="MessagePack-Core" selector="int64:">int64: anInteger	"Store the given signed, 64-bit integer on this (binary) stream."	| n |	(anInteger &lt; -16r8000000000000000) | (anInteger &gt;= 16r8000000000000000)		ifTrue: [self error: 'outside 64-bit integer range'].	anInteger &lt; 0		ifTrue: [n := 16r10000000000000000 + anInteger]		ifFalse: [n := anInteger].	self nextPut: (n digitAt: 8).	self nextPut: (n digitAt: 7).	self nextPut: (n digitAt: 6).	self nextPut: (n digitAt: 5).	self nextPut: (n digitAt: 4).	self nextPut: (n digitAt: 3).	self nextPut: (n digitAt: 2).	self nextPut: (n digitAt: 1).</body><body package="MessagePack-Core" selector="uint64">uint64	"Answer the next unsigned, 64-bit integer from this (binary) stream."	| n |	n := self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	^ n</body><body package="MessagePack-Core" selector="uint64:">uint64: anInteger	"Store the given unsigned, 64-bit integer on this (binary) stream."	(anInteger &lt; 0) | (anInteger &gt;= 16r10000000000000000)		ifTrue: [self error: 'outside unsigned 64-bit integer range'].			self nextPut: (anInteger digitAt: 8).	self nextPut: (anInteger digitAt: 7).	self nextPut: (anInteger digitAt: 6).	self nextPut: (anInteger digitAt: 5).	self nextPut: (anInteger digitAt: 4).	self nextPut: (anInteger digitAt: 3).	self nextPut: (anInteger digitAt: 2).	self nextPut: (anInteger digitAt: 1).</body></methods><methods><class-id>Core.Object</class-id> <category>*MessagePack-Core-packing</category><body package="MessagePack-Core" selector="messagePacked">messagePacked	^ MpEncoder encode: self</body></methods><methods><class-id>Core.Behavior</class-id> <category>*MessagePack-Core-unpacking</category><body package="MessagePack-Core" selector="fromMessagePack:">fromMessagePack: bytes	^ MpDecoder decode: bytes</body></methods><initialize><class-id>MpPortableUtil</class-id></initialize><initialize><class-id>MpVwPortableUtil</class-id></initialize><initialize><class-id>MpTypeMapper</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>PositionableStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection position readLimit writeLimit policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>